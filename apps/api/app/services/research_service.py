from collections.abc import Mapping
from typing import Any

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import get_settings
from app.db.models import (
    ResearchRun,
    ResearchRunStatus,
    ResearchStep,
    ResearchStepType,
)


def _basic_plan_for_query(query: str) -> dict[str, Any]:
    """
    Very simple, rule-based 'planner' that turns a query into a few
    generic sub-questions. This is a placeholder for an LLM-backed
    planner we'll add later.
    """
    return {
        "subquestions": [
            f"What are the key concepts and terms involved in: {query}?",
            f"What are the main options, approaches, or components related to: {query}?",
            f"What are the tradeoffs, risks, and recommendations for: {query}?",
        ],
        "notes": "Generated by basic planner v0 (rule-based, no LLM yet).",
    }


async def create_research_run_with_basic_plan(
    *,
    payload: Mapping[str, Any],
    db: AsyncSession,
) -> ResearchRun:
    """
    Create a new ResearchRun and a corresponding planner ResearchStep.

    For now, the 'planner' is a simple rule-based function. Later we will
    replace _basic_plan_for_query with an LLM-backed planner agent.
    """
    settings = get_settings()

    query = str(payload["query"])
    title = payload.get("title")

    run = ResearchRun(
        query=query,
        title=title,
        status=ResearchRunStatus.PENDING,
        model_provider=f"{settings.llm_provider}:{settings.llm_model}",
    )

    db.add(run)
    # flush so run.id is populated before we create the step
    await db.flush()

    plan_output = _basic_plan_for_query(query)

    step = ResearchStep(
        run_id=run.id,
        step_index=0,
        step_type=ResearchStepType.PLANNER,
        input={"query": query},
        output=plan_output,
    )

    db.add(step)
    await db.commit()
    await db.refresh(run)

    return run
